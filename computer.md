# 计算机基础

## 操作系统

### 进程

* 进程同步互斥的机制有两种： 信号量机制  管程  

  > 管程是一个含有数据结构和操作过程的模块 类似于进程  不同的是管程师被动的 进程是主动的 对于资源的pc操作方法都是管程内部的 但是信号量机制不是这样的 他的操作都是进程的方法

* 原子操作： 指的是执行某一个功能的一定的过程 他的特点是要么不执行要么执行完毕 不能中途中断 典型的对信号量访问的原子操作： wait signal

#### 经典的进程同步问题 

1. 生产者消费者问题：有个公共缓冲池 其中有n个缓冲区 生产者和消费者不可同时同时操作  生产者生产完毕放入缓冲池 消费者取走缓冲池中的资源 缓冲池满的时候不允许放入  为空时不允许取
2. 哲学家进餐问题 五个哲学家 五个筷子 哲学家饥饿时可以拿起左右的筷子进餐  最多只允许四个哲学家同时试图拿起筷子 
3. 读者写者问题 可以允许多个读者同时访问资源 不允许读者写者同时访问  

#### 进程的通信类型

1. 共享存储器系统  利用共享某些数据结构或者共享存储区 通过这写空间进行通信 

   > 共享数据结构是低级通信 比如使用有届缓冲区这种数据结构 需要程序员自己维护
   >
   > 共享存储区 操作系统提供一块通信的共享存储区 通信进程申请读写存储区 高级通信

2. 消息传递系统  直接利用操作系统提供的一对send和receive原语操作按照格式化的消息直接通信 可以传递大量数据 高级通信 应用最广泛

3. 管道通信 读写进程通过一个共享文件 称为pipe文件链接起来 发送进程通过字符流的形式将信息写入共享文件 管道机制需要提供互斥和同步能力 发送进程发送一定的数据量写入共享文件后 便去睡眠等待 接受进程唤醒后便去读取共享文件的数据 读完后便去睡眠等待 

#### 线程

1. 线程称为轻型进程或者进程元  引入线程是为了减少程序在并发执行时所付出的时空开销 (进程切换是需要为旧进程保存当前操作系统环境和参数并为新的进程创建环境)
2. 引入线程后 进程作为拥有资源的基本单位 而线程将作为独立调度和分派的基本单位

#### 作业

1. 作业是一个比程序更加广泛的概念  他包含了程序和数据而且还配有一份作业说明书 系统根据这个作业说明说来对程序进行控制
2. 作业步 在系统中作业所经过的若干个独立或者关联的处理步骤称为作业步  比如编译 装配 运行等
3. JCB 作业控制块 方便系统进程管理和调度 包含了作业标示 用户名称 账户 作业类型(cup繁忙型 i/o繁忙型 调度优先级 资源需求 要求的内存大小 i/o设备和数量， 进入系统时间 处理时间 资源使用情况)

#### 作业调度(接纳调度)

作业调度就是按照一定的算法把作业从外存的后备队列上装入内存 并为他们创建进程分配资源。再插入到就绪队列中 

作业调度既要考虑用户的需求 又要考虑系统的效率

作业调度每次需要考虑的两个问题

1. 决定接纳多少个作业到内存  这取决于多道程序度 即同时允许多少个作业在内存中运行 
2. 决定接纳哪些作业 取决于调度算法
   1. 先来先服务
   2. 短作业优先
   3. 响应比

**在批处理系统中作业进入系统后总是先驻留在外存的后备队列上  等待调度进入内存  然后在分时系统中为了及时响应用户的需求 作业可以直接被送入内存中  也就没有了中间的作业调度步骤 **

#### 低级调度 (进程调度或者短程调度)

是一种基本的调度的方式 在分时 实时 多道批处理系统中都必须配备

低级调度决定处于就绪队列中的哪个进程将获得处理机

1. 进程调度时 保存处理机的现场信息如计数器寄存器中的内存并保存进进程的PCB中相应的单元
2. 根据某种算法看 选取处理机  
3. 分配处理机并改为运行状态 恢复现场



#### 进程调度的三个基本机制

1. 排队器 就绪进程按照一定的方式排成一个或者多个队列  方便调度程序寻找
2. 分派器 将调度程序选定的进程取出 切换上下文 分配处理机
3. 上下文切换机制 保存当前进程的现场 恢复下一个待处理的进程的现场 

上下文切换需要花去一些时间 大约几毫秒 这点时间可执行上千条指令

#### 进程调度方式

1. 分抢占式调度  一旦将处理机分配给进程后 就得一直让它运行下去  除非程序自己执行完毕或者发生阻塞或者因为请求i/o中断   这中实现简单 系统开销小
2. 抢占方式 根据某种规则暂停正在执行的程序 将处理机分配给下一个进程 具体的规则比如

#### 抢占规则

1. 优先权 优先权高的进程将夺得正在执行的优先权低的进程的执行
2. 短作业优先 明显处理起来需要更短的进程将获得处理机
3. 时间片原则 各进程按照一定的时间片轮流执行 时间片用完后就停止执行重新调度进程来执行 

#### 中级调度

为了提高内存利用率和系统吞吐量

将那些暂时不能运行还占着内存资源的进程 调至外存上等待  此时的进程状态称为就绪驻外存或者叫挂起状态  当进程重新具备执行条件或者内存稍有空闲时  中级调度决定哪些进程重新调入内存挂在就绪队列上 状态改为就绪状态 



**进程调度的频率最高10～100ms一次  作业调度几分钟一次  中级调度介于中间**



#### 选择调度方式和调度算法的若干准则

面向用户时： 

1. 周转时间短 作业被提交给系统开始。到作业完成
2. 响应时间快。用户键入一个请求到接受到系统的第一个响应时间
3. 优先权。

面向系统时：

1. 系统吞吐量大
2. 处理机利用率好
3. 各类资源的平衡利用



#### 调度算法

1. 先来先服务调度算法(FCFS)

   * 适用于作业调度  进程调度
   * 适合长作业或者进程 不适合短作业
   * 适合cpu繁忙性作业 不适合i/0密集型作业

2. 短作业(进程)优先算法 SJF/SPF

   * 适用作业调度 进程调度
   * 适合短作业或者进程 
   * 对长作业不利 完全未考虑作业的紧迫程度 有可能导致长作业完全不被调度
   * 理论上是短作业(短表示用户提供的估计执行时间比较短) 但用户提供的时间不一定准确 所以可能不一定真正的得到短作业优先

3. 高优先权调度算法 FPF

   * 常用于批处理系统 适用于作业和进程调度
   * 分为抢占式调度算法 非抢占式调度算法  非抢占一旦获得处理机一直执行直到完成 后者如果在获得处理机后又出现了一个优先权更高的进程 则立即退出执行将执行权交给优先权更高的进程
   * 静态优先权和动态优先权 静态优先权创建进程的时候确定的 给一个优先数 0～7 0～255  动态优先权赋予一个初始值 但随着进程的推进和等待时间会增加改变

   优先权确定的依据

   * 进程类型 系统的高于用户的
   * 进程对资源的需求 内存需求量少的执行时间少的高于多的
   * 用户要求 进程的紧迫程度 

4. 高响应比优先调度算法

   * 是一种折中算法 既能考虑短作业又能考虑到长作业 
   * 响应比 = (等待时间+要求服务时间) / 要求服务时间

5. 时间片轮转调度算法 

   主要分为早期的简单的时间片轮转法和多级反馈队列调度算法 

   * 时间片轮转法 
     1. 所有的进程按照先来先服务的原则排成一个队列 每次调度时将cpu分配给一个队首进程 并令其执行一个时间片 时间片的大小从几毫秒到几百毫秒不等 如果时间到了计时器发出中断请求 停止执行 并将进程插入到队尾 
     2. 时间片的确定关系着系统性能  不可过大或过小
   * 多级反馈队列调度算法 
     1. 公认的较好的进程调度算法 
     2. 设置多个就绪队列 并为各个队列赋予不同的优先级 第一个队列的优先级最高 第二个次之 其余各个优先级逐个降低  赋予每一个队列一定的时间片 优先级越高时间片越低  
     3. 仅当前面的队列为空时才会执行后面的优先级低的队列 如果有新的进程进入优先级高的队列 则新进程会抢占正在执行的队列中的进程的执行权 
     4. 适合： 终端性作业用户(交互性作业)   短批处理作业用户  长批处理作业用户 

#### 实时调度

实时调度必须能满足对实时任务的截止时间的要求 因此所有的任务必须提供下列条件

1. 就绪时间 成为就绪状态的起始时间
2. 开始截止时间和完成截止时间 
3. 处理时间
4. 资源要求
5. 优先级

#### 实时调度算法分类

1. 非抢占式调度算法
   * 轮转调度算法 实时任务排成一个队列 调度程序每次只从队首调取任务处理 新来的插入到队尾 
   * 优先调度算法 排成一列 优先级高的任务插入到队首
2. 抢占式调度算法 
   * 基于时钟中断的强占 优先级高的任务到达后并不会立即抢占处理机 而是等到时钟中断到来时 才会抢占处理机
   * 立即抢占。

#### 常见的实时调度算法

1. 最早截止时间优先(EDF) 截止时间越早 优先级越高
2. 最低松弛度优先(LLF) 松弛度的计算： 比如一个任务必须在400ms时完成 他自己本身执行需要的时间是150ms  所以处理机必须在250ms这个时间点之前开始执行 所以他的松弛度就是 250ms 